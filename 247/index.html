<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>ç¬¬247å¤© Â· å€¾æ–œå¹³è¡¡å¡”</title>
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        font-family: "Poppins", "Noto Sans SC", system-ui, -apple-system, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
        color: #fff;
        overflow: hidden;
        position: fixed;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        background: radial-gradient(
            circle at 30% 20%,
            rgba(255, 255, 255, 0.1),
            transparent 40%
          ),
          radial-gradient(circle at 80% 80%, rgba(255, 120, 200, 0.15), transparent 50%);
        z-index: 0;
      }
      #gameCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }
      .hud {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        padding: 16px 20px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        pointer-events: none;
        z-index: 10;
        gap: 12px;
      }
      .info-card {
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 16px;
        padding: 12px 18px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .info-card .label {
        font-size: 0.7rem;
        letter-spacing: 0.15em;
        opacity: 0.8;
        text-transform: uppercase;
      }
      .info-card .value {
        font-size: 1.6rem;
        font-weight: 700;
        letter-spacing: 0.05em;
      }
      .status-text {
        position: fixed;
        bottom: 120px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(10px);
        padding: 10px 24px;
        border-radius: 20px;
        font-size: 0.9rem;
        letter-spacing: 0.05em;
        z-index: 10;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      .status-text.show {
        opacity: 1;
      }
      .tilt-indicator {
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        width: 200px;
        height: 8px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        overflow: hidden;
        z-index: 10;
      }
      .tilt-indicator::before {
        content: "";
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 2px;
        height: 14px;
        background: rgba(255, 255, 255, 0.6);
        z-index: 2;
      }
      .tilt-bar {
        position: absolute;
        left: 50%;
        top: 0;
        width: 20px;
        height: 100%;
        background: linear-gradient(90deg, #ff6ec4, #ffa06e);
        border-radius: 10px;
        transform: translateX(-50%);
        transition: left 0.1s ease-out;
      }
      .overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.85);
        z-index: 100;
        transition: opacity 0.4s ease;
        padding: 24px;
      }
      .overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }
      .modal {
        width: min(420px, 100%);
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.95), rgba(118, 75, 162, 0.95));
        border-radius: 28px;
        padding: 32px 24px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        text-align: center;
        backdrop-filter: blur(20px);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      }
      .modal h1 {
        margin: 0 0 12px;
        font-size: 2rem;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }
      .modal .subtitle {
        font-size: 0.85rem;
        letter-spacing: 0.3em;
        color: #ffd6f0;
        margin-bottom: 8px;
      }
      .modal p {
        margin: 0 0 16px;
        line-height: 1.7;
        opacity: 0.95;
      }
      .modal ul {
        text-align: left;
        padding-left: 20px;
        margin: 0 auto 24px;
        max-width: 340px;
        font-size: 0.88rem;
        line-height: 1.8;
      }
      .modal li + li {
        margin-top: 8px;
      }
      .modal button {
        width: 100%;
        padding: 16px 20px;
        border-radius: 16px;
        border: none;
        font-size: 1.05rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .modal button:active {
        transform: scale(0.98);
      }
      #startBtn {
        background: linear-gradient(120deg, #fff, #ffc4e8);
        color: #5a3f8a;
        margin-bottom: 12px;
        box-shadow: 0 6px 20px rgba(255, 255, 255, 0.3);
      }
      #motionBtn {
        background: rgba(255, 255, 255, 0.15);
        border: 1.5px solid rgba(255, 255, 255, 0.4);
        color: #fff;
      }
      .stats {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid rgba(255, 255, 255, 0.3);
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
      }
      .stats.hidden {
        display: none;
      }
      .stat-item {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .stat-item .label {
        font-size: 0.75rem;
        letter-spacing: 0.2em;
        opacity: 0.85;
      }
      .stat-item .value {
        font-size: 1.8rem;
        font-weight: 700;
      }
      .calibrate-btn {
        position: fixed;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        padding: 8px 20px;
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.4);
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(10px);
        color: #fff;
        font-size: 0.8rem;
        cursor: pointer;
        z-index: 10;
        pointer-events: auto;
      }
      @media (max-width: 400px) {
        .modal h1 {
          font-size: 1.6rem;
        }
        .info-card .value {
          font-size: 1.3rem;
        }
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="hud">
      <div class="info-card">
        <div class="label">LOVE DAY</div>
        <div class="value">247</div>
      </div>
      <div class="info-card">
        <div class="label">å¾—åˆ†</div>
        <div class="value" id="scoreValue">0</div>
      </div>
      <div class="info-card">
        <div class="label">é«˜åº¦</div>
        <div class="value" id="heightValue">0</div>
      </div>
    </div>

    <div class="status-text" id="statusText">å‡†å¤‡å»ºå¡”</div>
    
    <div class="tilt-indicator">
      <div class="tilt-bar" id="tiltBar"></div>
    </div>

    <button class="calibrate-btn" id="calibrateBtn">æ ¡å‡†å€¾æ–œ</button>

    <div class="overlay" id="overlay">
      <div class="modal">
        <div class="subtitle" id="modalSubtitle">çºªå¿µæ‹çˆ±ç¬¬247å¤©</div>
        <h1 id="modalTitle">ğŸ’— å€¾æ–œå¹³è¡¡å¡” ğŸ’—</h1>
        <p id="modalMessage">
          ç”¨æ‰‹æœºå€¾æ–œæ§åˆ¶åº•éƒ¨å¹³å°ï¼Œè®©å¿ƒå½¢ç§¯æœ¨ç¨³ç¨³è½åœ¨å¡”é¡¶ã€‚
          ä¿æŒå¹³è¡¡ï¼Œå»ºé€ å±äºæˆ‘ä»¬çš„çˆ±æƒ…é«˜å¡”ï¼
        </p>
        <ul id="instructions">
          <li>å·¦å³å€¾æ–œæ‰‹æœºæ§åˆ¶å¹³å°è§’åº¦</li>
          <li>å¿ƒå½¢ç§¯æœ¨ä¼šä»ä¸Šæ–¹æ‰è½</li>
          <li>ç‚¹å‡»å±å¹•å¯ä»¥æå‰æ‰è½ç§¯æœ¨</li>
          <li>ç§¯æœ¨æ‰å‡ºå±å¹•å¤–æ¸¸æˆç»“æŸ</li>
        </ul>
        <div class="stats hidden" id="resultStats">
          <div class="stat-item">
            <div class="label">æœ€ç»ˆå¾—åˆ†</div>
            <div class="value" id="finalScore">0</div>
          </div>
          <div class="stat-item">
            <div class="label">æœ€é«˜é«˜åº¦</div>
            <div class="value" id="finalHeight">0</div>
          </div>
        </div>
        <button id="startBtn">å¼€å§‹å»ºå¡”</button>
        <button id="motionBtn">å¼€å¯é‡åŠ›æ„Ÿåº”</button>
      </div>
    </div>

    <script>
      (() => {
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const overlay = document.getElementById("overlay");
        const startBtn = document.getElementById("startBtn");
        const motionBtn = document.getElementById("motionBtn");
        const statusText = document.getElementById("statusText");
        const scoreValue = document.getElementById("scoreValue");
        const heightValue = document.getElementById("heightValue");
        const tiltBar = document.getElementById("tiltBar");
        const calibrateBtn = document.getElementById("calibrateBtn");
        const modalTitle = document.getElementById("modalTitle");
        const modalMessage = document.getElementById("modalMessage");
        const resultStats = document.getElementById("resultStats");
        const finalScore = document.getElementById("finalScore");
        const finalHeight = document.getElementById("finalHeight");
        const instructions = document.getElementById("instructions");

        // Matter.js æ¨¡å—
        const { Engine, Render, Runner, Bodies, Composite, Events, Body, Vector } = Matter;

        let engine;
        let runner;
        let platform;
        let blocks = [];
        let ground;
        let walls;
        
        let playing = false;
        let score = 0;
        let maxHeight = 0;
        let nextBlockTimer = 0;
        let currentBlock = null;
        let blockCount = 0;

        // è®¾å¤‡å€¾æ–œæ•°æ®
        const orientation = { gamma: 0, beta: 0 };
        const calibration = { gamma: 0, beta: 0 };
        let orientationActive = false;
        let deviceMotionEnabled = false;

        // è§¦æ‘¸æ§åˆ¶
        let touchControl = { x: 0.5 };

        const config = {
          maxTilt: 30,
          platformTiltSpeed: 0.12,
          blockSpawnDelay: 2.5,
          blockSize: 40,
        };

        function setCanvasSize() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }

        function clamp(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }

        // åˆå§‹åŒ–ç‰©ç†å¼•æ“
        function initPhysics() {
          if (engine) {
            Composite.clear(engine.world);
            Engine.clear(engine);
          }

          engine = Engine.create({
            gravity: { x: 0, y: 1 }
          });

          // åœ°é¢
          ground = Bodies.rectangle(
            canvas.width / 2,
            canvas.height + 25,
            canvas.width,
            50,
            { isStatic: true, label: 'ground' }
          );

          // å·¦å³å¢™å£
          const leftWall = Bodies.rectangle(-25, canvas.height / 2, 50, canvas.height * 2, {
            isStatic: true,
            label: 'wall'
          });
          const rightWall = Bodies.rectangle(canvas.width + 25, canvas.height / 2, 50, canvas.height * 2, {
            isStatic: true,
            label: 'wall'
          });

          walls = [leftWall, rightWall];

          // å¹³å°
          const platformY = canvas.height - 120;
          platform = Bodies.rectangle(canvas.width / 2, platformY, 180, 12, {
            isStatic: false,
            friction: 0.8,
            restitution: 0.2,
            label: 'platform',
            density: 0.001
          });
          Body.setInertia(platform, Infinity);

          Composite.add(engine.world, [ground, leftWall, rightWall, platform]);

          runner = Runner.create();
          Runner.run(runner, engine);

          // ç›‘å¬ç¢°æ’
          Events.on(engine, 'collisionStart', handleCollision);
        }

        function handleCollision(event) {
          event.pairs.forEach(pair => {
            const { bodyA, bodyB } = pair;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ç‰©å—æ‰å‡ºå±å¹•
            [bodyA, bodyB].forEach(body => {
              if (body.label === 'block' && body.position.y > canvas.height + 100) {
                endGame();
              }
            });
          });
        }

        // ç»˜åˆ¶å¿ƒå½¢
        function drawHeart(ctx, x, y, size, color) {
          ctx.save();
          ctx.translate(x, y);
          ctx.fillStyle = color;
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.lineWidth = 2;
          
          ctx.beginPath();
          const topCurveHeight = size * 0.3;
          ctx.moveTo(0, topCurveHeight);
          
          // å·¦åŠè¾¹å¿ƒå½¢
          ctx.bezierCurveTo(
            -size / 2, -topCurveHeight,
            -size, topCurveHeight / 3,
            0, size
          );
          
          // å³åŠè¾¹å¿ƒå½¢
          ctx.bezierCurveTo(
            size, topCurveHeight / 3,
            size / 2, -topCurveHeight,
            0, topCurveHeight
          );
          
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }

        // åˆ›å»ºå¿ƒå½¢ç‰©å—
        function createBlock(x, y) {
          const size = config.blockSize;
          const block = Bodies.circle(x, y, size / 2, {
            restitution: 0.3,
            friction: 0.8,
            density: 0.002,
            label: 'block'
          });
          
          block.heartSize = size * 0.7;
          block.heartColor = `hsl(${320 + Math.random() * 40}, 90%, ${60 + Math.random() * 20}%)`;
          
          Composite.add(engine.world, block);
          blocks.push(block);
          blockCount++;
          
          return block;
        }

        // æ‰è½æ–°ç§¯æœ¨
        function spawnBlock() {
          if (!playing) return;
          
          const x = canvas.width / 2 + (Math.random() - 0.5) * 100;
          const y = -50;
          currentBlock = createBlock(x, y);
          nextBlockTimer = config.blockSpawnDelay;
          
          score += 1;
          flashStatus(`ç¬¬ ${blockCount} å—å¿ƒå½¢ç§¯æœ¨`);
        }

        // å¤„ç†è®¾å¤‡å€¾æ–œ
        function handleOrientation(event) {
          orientation.gamma = event.gamma ?? 0;
          orientation.beta = event.beta ?? 0;
          orientationActive = true;
        }

        async function enableMotion() {
          if (!("DeviceOrientationEvent" in window)) {
            flashStatus("è®¾å¤‡æ— é‡åŠ›ä¼ æ„Ÿå™¨", 2000);
            return false;
          }
          
          if (
            typeof DeviceOrientationEvent.requestPermission === "function" &&
            !deviceMotionEnabled
          ) {
            try {
              const response = await DeviceOrientationEvent.requestPermission();
              if (response !== "granted") {
                flashStatus("éœ€è¦å¼€å¯è¿åŠ¨ä¸æ–¹å‘æƒé™", 2500);
                return false;
              }
            } catch (err) {
              flashStatus("æˆæƒå¤±è´¥", 2000);
              return false;
            }
          }
          
          if (!deviceMotionEnabled) {
            window.addEventListener("deviceorientation", handleOrientation, true);
            deviceMotionEnabled = true;
            flashStatus("é‡åŠ›æ„Ÿåº”å·²è¿æ¥", 1800);
          }
          return true;
        }

        function calibrate() {
          calibration.gamma = orientation.gamma;
          calibration.beta = orientation.beta;
          flashStatus("å·²æ ¡å‡†ä¸ºä¸­ç«‹ä½ç½®", 1500);
        }

        // è·å–æ ‡å‡†åŒ–å€¾æ–œå€¼
        function getNormalizedTilt() {
          if (!orientationActive) {
            // ä½¿ç”¨è§¦æ‘¸æ§åˆ¶
            return (touchControl.x - 0.5) * 2;
          }
          
          const tiltX = orientation.gamma - calibration.gamma;
          return clamp(tiltX / config.maxTilt, -1, 1);
        }

        function flashStatus(text, duration = 1400) {
          statusText.textContent = text;
          statusText.classList.add('show');
          if (statusText._timer) clearTimeout(statusText._timer);
          statusText._timer = setTimeout(() => {
            statusText.classList.remove('show');
          }, duration);
        }

        function updateTiltIndicator(tilt) {
          const percent = ((tilt + 1) / 2) * 100;
          tiltBar.style.left = `${percent}%`;
        }

        function calculateMaxHeight() {
          let highest = canvas.height;
          blocks.forEach(block => {
            if (block.position.y < highest) {
              highest = block.position.y;
            }
          });
          return Math.max(0, Math.round((canvas.height - 120 - highest) / 10));
        }

        function update(delta) {
          if (!playing) return;

          const tilt = getNormalizedTilt();
          updateTiltIndicator(tilt);

          // æ§åˆ¶å¹³å°å€¾æ–œ
          const targetAngle = tilt * 0.4;
          const currentAngle = platform.angle;
          const newAngle = currentAngle + (targetAngle - currentAngle) * config.platformTiltSpeed;
          Body.setAngle(platform, newAngle);
          Body.setAngularVelocity(platform, 0);
          Body.setVelocity(platform, { x: 0, y: 0 });

          // å®šæ—¶æ‰è½ç§¯æœ¨
          nextBlockTimer -= delta;
          if (nextBlockTimer <= 0 && (!currentBlock || currentBlock.position.y > 100)) {
            spawnBlock();
          }

          // æ›´æ–°æœ€é«˜é«˜åº¦
          maxHeight = calculateMaxHeight();

          // æ£€æŸ¥ç‰©å—æ˜¯å¦æ‰å‡ºå±å¹•
          blocks = blocks.filter(block => {
            if (block.position.x < -100 || block.position.x > canvas.width + 100 ||
                block.position.y > canvas.height + 150) {
              Composite.remove(engine.world, block);
              if (playing) {
                endGame();
              }
              return false;
            }
            return true;
          });

          updateHUD();
        }

        function updateHUD() {
          scoreValue.textContent = score;
          heightValue.textContent = maxHeight;
        }

        function render() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // ç»˜åˆ¶èƒŒæ™¯ç²’å­
          ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
          for (let i = 0; i < 30; i++) {
            const x = (Date.now() * 0.01 + i * 30) % canvas.width;
            const y = (i * 47) % canvas.height;
            ctx.fillRect(x, y, 2, 2);
          }

          // ç»˜åˆ¶å¹³å°
          ctx.save();
          ctx.translate(platform.position.x, platform.position.y);
          ctx.rotate(platform.angle);
          
          const gradient = ctx.createLinearGradient(-90, 0, 90, 0);
          gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
          gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
          gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(-90, -6, 180, 12);
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.lineWidth = 2;
          ctx.strokeRect(-90, -6, 180, 12);
          ctx.restore();

          // ç»˜åˆ¶æ‰€æœ‰å¿ƒå½¢ç§¯æœ¨
          blocks.forEach(block => {
            ctx.save();
            ctx.translate(block.position.x, block.position.y);
            ctx.rotate(block.angle);
            drawHeart(ctx, 0, 0, block.heartSize, block.heartColor);
            ctx.restore();
          });

          requestAnimationFrame(render);
        }

        function resetGame() {
          playing = true;
          score = 0;
          maxHeight = 0;
          blockCount = 0;
          nextBlockTimer = 1;
          currentBlock = null;
          blocks = [];
          
          overlay.classList.add('hidden');
          resultStats.classList.add('hidden');
          instructions.style.display = 'block';
          
          initPhysics();
          flashStatus("å¼€å§‹å»ºå¡”ï¼");
        }

        function endGame() {
          if (!playing) return;
          
          playing = false;
          overlay.classList.remove('hidden');
          modalTitle.textContent = 'å¡”å€’äº†ï¼';
          modalMessage.textContent = `æˆ‘ä»¬ä¸€èµ·å»ºäº† ${blockCount} å±‚çš„çˆ±æƒ…é«˜å¡”ï¼å†æ¥ä¸€æ¬¡ï¼Œå»ºå¾—æ›´é«˜ï¼`;
          instructions.style.display = 'none';
          resultStats.classList.remove('hidden');
          finalScore.textContent = score;
          finalHeight.textContent = maxHeight;
          flashStatus("æ¸¸æˆç»“æŸ", 3000);
        }

        function handleTouch(event) {
          if (!playing) return;
          
          const touch = event.touches?.[0] || event;
          touchControl.x = clamp(touch.clientX / canvas.width, 0, 1);
          
          // ç‚¹å‡»å¯ä»¥ç«‹å³æ‰è½æ–°ç§¯æœ¨
          if (event.type === 'pointerdown' && nextBlockTimer > 0.5) {
            nextBlockTimer = 0;
          }
        }

        function bindEvents() {
          startBtn.addEventListener("click", async () => {
            await enableMotion();
            calibrate();
            resetGame();
          });
          
          motionBtn.addEventListener("click", async () => {
            const granted = await enableMotion();
            modalMessage.textContent = granted
              ? "é‡åŠ›æ„Ÿåº”å·²å°±ç»ªï¼å·¦å³å€¾æ–œæ‰‹æœºæ§åˆ¶å¹³å°ã€‚"
              : "å¯ä»¥è§¦æ‘¸å±å¹•å·¦å³ä¸¤ä¾§æ§åˆ¶å¹³å°ã€‚";
          });
          
          calibrateBtn.addEventListener("click", calibrate);
          
          canvas.addEventListener("pointerdown", handleTouch);
          canvas.addEventListener("pointermove", handleTouch);
          canvas.addEventListener("touchstart", handleTouch);
          canvas.addEventListener("touchmove", handleTouch);
          
          window.addEventListener("resize", () => {
            setCanvasSize();
            if (playing) {
              resetGame();
            }
          });
        }

        function init() {
          setCanvasSize();
          initPhysics();
          bindEvents();
          
          // æ¸¸æˆå¾ªç¯
          let lastTime = Date.now();
          function gameLoop() {
            const now = Date.now();
            const delta = (now - lastTime) / 1000;
            lastTime = now;
            
            update(Math.min(delta, 0.033));
            requestAnimationFrame(gameLoop);
          }
          
          gameLoop();
          render();
        }

        init();
      })();
    </script>
  </body>
</html>

