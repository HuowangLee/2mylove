<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <title>ğŸ’ æ‹çˆ±248å¤©çºªå¿µ - çˆ±çš„è½¨è¿¹ ğŸ’</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative;
            padding: 5px;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: pan-y;
        }

        .hearts {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .heart {
            position: absolute;
            color: rgba(255, 105, 180, 0.3);
            animation: float 10s infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        .container {
            position: relative;
            z-index: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 100%;
            margin: 10px 0;
        }

        h1 {
            text-align: center;
            color: #ff6b9d;
            margin-bottom: 8px;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            line-height: 1.3;
        }

        .subtitle {
            text-align: center;
            color: #667eea;
            margin-bottom: 12px;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            gap: 8px;
            flex-wrap: wrap;
        }

        .level-info {
            font-size: 1em;
            color: #764ba2;
            font-weight: bold;
            white-space: nowrap;
        }

        .btn-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
        }

        .btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .btn-start {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-start:active {
            background: linear-gradient(135deg, #e083eb 0%, #e5475c 100%);
        }

        .btn-reset {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-reset:active {
            background: linear-gradient(135deg, #566eda 0%, #663b92 100%);
        }

        .btn-clear {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #764ba2;
        }

        .btn-clear:active {
            background: linear-gradient(135deg, #eedcc2 0%, #eca68f 100%);
        }

        #gameCanvas {
            border: 3px solid #ff6b9d;
            border-radius: 12px;
            display: block;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            background: linear-gradient(180deg, #e0f7ff 0%, #ffe6f0 100%);
            touch-action: none;
            width: 100%;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }

        .instructions {
            margin-top: 12px;
            padding: 12px;
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            border-radius: 10px;
            color: #764ba2;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .instructions strong {
            color: #f5576c;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 30px 20px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalPop 0.5s ease-out;
            max-width: 90%;
            margin: 0 10px;
        }

        @keyframes modalPop {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .modal h2 {
            font-size: 1.8em;
            margin-bottom: 15px;
            color: #ff6b9d;
            line-height: 1.3;
        }

        .modal p {
            font-size: 1.1em;
            color: #667eea;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            .container {
                padding: 10px;
                border-radius: 12px;
            }
            h1 {
                font-size: 1.3em;
                margin-bottom: 6px;
            }
            .subtitle {
                font-size: 0.8em;
                margin-bottom: 10px;
            }
            .btn {
                padding: 8px 12px;
                font-size: 0.85em;
            }
            .game-info {
                margin-bottom: 10px;
            }
            .instructions {
                font-size: 0.8em;
                padding: 10px;
                margin-top: 10px;
            }
            .modal h2 {
                font-size: 1.5em;
            }
            .modal p {
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 3px;
            }
            .container {
                padding: 8px;
                border-radius: 10px;
            }
            h1 {
                font-size: 1.2em;
            }
            .subtitle {
                font-size: 0.75em;
            }
            .btn {
                padding: 7px 10px;
                font-size: 0.8em;
            }
            .level-info {
                font-size: 0.9em;
            }
            .instructions {
                font-size: 0.75em;
            }
        }

        /* æ¨ªå±æç¤º */
        @media (max-width: 768px) and (orientation: landscape) {
            .container {
                max-width: 95vh;
            }
        }
    </style>
</head>
<body>
    <div class="hearts" id="hearts"></div>

    <div class="container">
        <h1>ğŸ’– æ‹çˆ±248å¤©çºªå¿µ ğŸ’–</h1>
        <p class="subtitle">ç”¨çˆ±çš„è½¨è¿¹ï¼Œå¼•å¯¼æˆ‘ä»¬çš„å°çƒèµ°å‘å¹¸ç¦ç»ˆç‚¹~</p>
        
        <div class="game-info">
            <div class="level-info">å…³å¡ <span id="levelDisplay">1</span></div>
            <div class="btn-group">
                <button class="btn btn-clear" id="clearBtn">æ¸…é™¤</button>
                <button class="btn btn-start" id="startBtn">å¼€å§‹</button>
                <button class="btn btn-reset" id="resetBtn">é‡ç½®</button>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div class="instructions">
            <strong>ğŸ® æ¸¸æˆè¯´æ˜ï¼š</strong><br>
            1ï¸âƒ£ ç”¨æ‰‹æŒ‡ç”»çº¿ï¼Œä¸ºå°çƒåˆ›é€ è½¨é“<br>
            2ï¸âƒ£ ç‚¹å‡»"å¼€å§‹"åï¼Œç²‰è‰²å°çƒä¼šæ²¿ç€ä½ ç”»çš„çº¿æ»šåŠ¨<br>
            3ï¸âƒ£ é¿å¼€çº¢è‰²éšœç¢å’Œå°–åˆºï¼Œè®©å°çƒåˆ°è¾¾çº¢å¿ƒç»ˆç‚¹<br>
            4ï¸âƒ£ å®Œæˆå…³å¡åè¿›å…¥ä¸‹ä¸€å…³ï¼Œä¸€å…±248å…³ï¼ğŸ’
        </div>
    </div>

    <div class="modal" id="winModal">
        <div class="modal-content">
            <h2>ğŸ‰ æ­å–œè¿‡å…³ï¼ğŸ‰</h2>
            <p id="winMessage">ä½ çœŸæ£’ï¼</p>
            <button class="btn btn-start" id="nextLevelBtn">ä¸‹ä¸€å…³</button>
        </div>
    </div>

    <script>
        // ç”ŸæˆèƒŒæ™¯çˆ±å¿ƒ
        const heartsContainer = document.getElementById('hearts');
        for (let i = 0; i < 15; i++) {
            const heart = document.createElement('div');
            heart.className = 'heart';
            heart.innerHTML = 'ğŸ’–';
            heart.style.left = Math.random() * 100 + '%';
            heart.style.top = Math.random() * 100 + '%';
            heart.style.fontSize = (Math.random() * 30 + 20) + 'px';
            heart.style.animationDelay = Math.random() * 5 + 's';
            heartsContainer.appendChild(heart);
        }

        // æ¸¸æˆå˜é‡
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let currentLevel = 1;
        const maxLevel = 248;
        
        let isDrawing = false;
        let isGameRunning = false;
        let drawnLines = [];
        let currentLine = [];
        
        // å°çƒå±æ€§
        let ball = {
            x: 0,
            y: 0,
            radius: 12,
            vx: 0,
            vy: 0,
            color: '#ff6b9d'
        };
        
        // ç‰©ç†å‚æ•°
        const gravity = 0.4;
        const friction = 0.985;
        const bounce = 0.65;
        
        // å…³å¡é…ç½®
        let startPoint = { x: 50, y: 100 };
        let endPoint = { x: 750, y: 100 };
        let obstacles = [];
        let spikes = [];
        
        // è®¾ç½®Canvaså°ºå¯¸è‡ªé€‚åº”
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 30; // å‡å»padding
            const isMobile = window.innerWidth <= 768;
            
            // ç§»åŠ¨ç«¯ä½¿ç”¨æ›´å¤§çš„ç”»å¸ƒæ¯”ä¾‹
            let canvasWidth, canvasHeight;
            
            if (isMobile) {
                canvasWidth = Math.min(containerWidth, window.innerWidth - 40);
                canvasHeight = Math.min(canvasWidth * 1.2, window.innerHeight * 0.55);
            } else {
                canvasWidth = Math.min(containerWidth, 800);
                canvasHeight = canvasWidth * 0.625; // 16:10æ¯”ä¾‹
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // æ ¹æ®å±å¹•å¤§å°è°ƒæ•´å°çƒå¤§å°
            ball.radius = Math.max(10, Math.min(canvasWidth, canvasHeight) * 0.025);
            
            // é‡æ–°åˆå§‹åŒ–å…³å¡ï¼ˆä»¥é€‚åº”æ–°å°ºå¯¸ï¼‰
            if (currentLevel) {
                initLevel(currentLevel);
                draw();
            }
        }
        
        // åˆå§‹è®¾ç½®å’Œçª—å£å¤§å°æ”¹å˜æ—¶è°ƒæ•´
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // åˆå§‹åŒ–å…³å¡
        function initLevel(level) {
            obstacles = [];
            spikes = [];
            
            // æ ¹æ®å…³å¡æ•°è°ƒæ•´éš¾åº¦
            const difficulty = Math.min(Math.floor(level / 10), 15);
            
            // è®¾ç½®èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆç›¸å¯¹äºcanvaså¤§å°ï¼‰
            startPoint = { 
                x: canvas.width * 0.08, 
                y: canvas.height * 0.2 
            };
            endPoint = { 
                x: canvas.width * 0.92, 
                y: canvas.height * 0.85 
            };
            
            // ç”Ÿæˆéšœç¢ç‰©ï¼ˆç›¸å¯¹ä½ç½®ï¼‰
            const numObstacles = 2 + Math.min(difficulty, 5);
            for (let i = 0; i < numObstacles; i++) {
                const xProgress = (i + 1) / (numObstacles + 1);
                obstacles.push({
                    x: canvas.width * 0.15 + (canvas.width * 0.7 * xProgress) + (Math.random() - 0.5) * 50,
                    y: canvas.height * 0.3 + Math.random() * canvas.height * 0.4,
                    width: canvas.width * 0.08 + Math.random() * 20,
                    height: canvas.height * 0.06 + Math.random() * 15
                });
            }
            
            // ç”Ÿæˆå°–åˆºï¼ˆç›¸å¯¹ä½ç½®ï¼‰
            const numSpikes = 1 + Math.floor(difficulty / 3);
            for (let i = 0; i < numSpikes; i++) {
                const xProgress = (i + 0.5) / numSpikes;
                spikes.push({
                    x: canvas.width * 0.2 + (canvas.width * 0.6 * xProgress) + (Math.random() - 0.5) * 40,
                    y: canvas.height * 0.7 + Math.random() * canvas.height * 0.2,
                    size: Math.min(canvas.width, canvas.height) * 0.025
                });
            }
            
            // é‡ç½®å°çƒ
            resetBall();
        }
        
        function resetBall() {
            ball.x = startPoint.x;
            ball.y = startPoint.y;
            ball.vx = 0;
            ball.vy = 0;
        }
        
        // ç»˜åˆ¶å‡½æ•°
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#e0f7ff');
            gradient.addColorStop(1, '#ffe6f0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function drawStartPoint() {
            const radius = Math.max(12, Math.min(canvas.width, canvas.height) * 0.03);
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(startPoint.x, startPoint.y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // æè¾¹
            ctx.strokeStyle = '#2E7D32';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.max(10, radius * 0.8)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('èµ·ç‚¹', startPoint.x, startPoint.y);
        }
        
        function drawEndPoint() {
            const scale = Math.max(1, Math.min(canvas.width, canvas.height) / 400);
            
            // ç»˜åˆ¶çº¢å¿ƒ
            ctx.fillStyle = '#ff1744';
            ctx.save();
            ctx.translate(endPoint.x, endPoint.y);
            ctx.scale(scale, scale);
            ctx.beginPath();
            ctx.moveTo(0, 5);
            ctx.bezierCurveTo(-10, -5, -20, -5, -20, 5);
            ctx.bezierCurveTo(-20, 15, 0, 25, 0, 25);
            ctx.bezierCurveTo(0, 25, 20, 15, 20, 5);
            ctx.bezierCurveTo(20, -5, 10, -5, 0, 5);
            ctx.fill();
            ctx.restore();
            
            // æ·»åŠ å…‰æ™•æ•ˆæœ
            const glowGradient = ctx.createRadialGradient(
                endPoint.x, endPoint.y, 10 * scale, 
                endPoint.x, endPoint.y, 30 * scale
            );
            glowGradient.addColorStop(0, 'rgba(255, 23, 68, 0.4)');
            glowGradient.addColorStop(1, 'rgba(255, 23, 68, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(endPoint.x, endPoint.y, 30 * scale, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawObstacles() {
            obstacles.forEach(obs => {
                ctx.fillStyle = '#ff5252';
                ctx.strokeStyle = '#d32f2f';
                ctx.lineWidth = 2;
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
                
                // æ·»åŠ å±é™©æ ‡å¿—
                ctx.fillStyle = '#ffeb3b';
                const fontSize = Math.max(14, Math.min(obs.width, obs.height) * 0.6);
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('âš ', obs.x + obs.width / 2, obs.y + obs.height / 2);
            });
        }
        
        function drawSpikes() {
            spikes.forEach(spike => {
                ctx.fillStyle = '#ff1744';
                ctx.beginPath();
                const points = 8;
                for (let i = 0; i < points; i++) {
                    const angle = (Math.PI * 2 * i) / points;
                    const radius = i % 2 === 0 ? spike.size : spike.size / 2;
                    const x = spike.x + Math.cos(angle) * radius;
                    const y = spike.y + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
            });
        }
        
        function drawLines() {
            const lineWidth = Math.max(3, Math.min(canvas.width, canvas.height) * 0.01);
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            drawnLines.forEach(line => {
                if (line.length < 2) return;
                
                // ç»˜åˆ¶çº¿æ¡é˜´å½±
                ctx.strokeStyle = 'rgba(118, 75, 162, 0.3)';
                ctx.lineWidth = lineWidth + 2;
                ctx.beginPath();
                ctx.moveTo(line[0].x, line[0].y + 2);
                for (let i = 1; i < line.length; i++) {
                    ctx.lineTo(line[i].x, line[i].y + 2);
                }
                ctx.stroke();
                
                // ç»˜åˆ¶ä¸»çº¿æ¡
                ctx.strokeStyle = '#764ba2';
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(line[0].x, line[0].y);
                for (let i = 1; i < line.length; i++) {
                    ctx.lineTo(line[i].x, line[i].y);
                }
                ctx.stroke();
            });
            
            // ç»˜åˆ¶å½“å‰æ­£åœ¨ç”»çš„çº¿ï¼ˆæ›´é†’ç›®ï¼‰
            if (currentLine.length > 1) {
                ctx.strokeStyle = 'rgba(240, 147, 251, 0.5)';
                ctx.lineWidth = lineWidth + 3;
                ctx.beginPath();
                ctx.moveTo(currentLine[0].x, currentLine[0].y);
                for (let i = 1; i < currentLine.length; i++) {
                    ctx.lineTo(currentLine[i].x, currentLine[i].y);
                }
                ctx.stroke();
                
                ctx.strokeStyle = '#f093fb';
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(currentLine[0].x, currentLine[0].y);
                for (let i = 1; i < currentLine.length; i++) {
                    ctx.lineTo(currentLine[i].x, currentLine[i].y);
                }
                ctx.stroke();
            }
        }
        
        function drawBall() {
            // å°çƒé˜´å½±
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(ball.x, ball.y + ball.radius + 5, ball.radius * 0.8, ball.radius * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å°çƒä¸»ä½“
            const ballGradient = ctx.createRadialGradient(
                ball.x - ball.radius / 3, 
                ball.y - ball.radius / 3, 
                ball.radius / 4,
                ball.x, 
                ball.y, 
                ball.radius
            );
            ballGradient.addColorStop(0, '#ffb3d9');
            ballGradient.addColorStop(1, ball.color);
            ctx.fillStyle = ballGradient;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // å°çƒè½®å»“
            ctx.strokeStyle = '#ff1744';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function draw() {
            drawBackground();
            drawStartPoint();
            drawEndPoint();
            drawObstacles();
            drawSpikes();
            drawLines();
            drawBall();
        }
        
        // ç‰©ç†æ›´æ–°
        function updateBall() {
            if (!isGameRunning) return;
            
            // åº”ç”¨é‡åŠ›
            ball.vy += gravity;
            
            // åº”ç”¨é€Ÿåº¦
            ball.x += ball.vx;
            ball.y += ball.vy;
            
            // ä¸ç»˜åˆ¶çš„çº¿ç¢°æ’æ£€æµ‹
            drawnLines.forEach(line => {
                for (let i = 0; i < line.length - 1; i++) {
                    const p1 = line[i];
                    const p2 = line[i + 1];
                    const collision = checkLineCircleCollision(p1, p2, ball);
                    
                    if (collision) {
                        // è®¡ç®—çº¿æ®µæ–¹å‘å‘é‡
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        
                        if (len === 0) continue;
                        
                        // å•ä½åˆ‡å‘é‡ï¼ˆæ²¿ç€çº¿æ®µï¼‰
                        const tx = dx / len;
                        const ty = dy / len;
                        
                        // å•ä½æ³•å‘é‡ï¼ˆå‚ç›´äºçº¿æ®µï¼Œå‘ä¸Šï¼‰
                        let nx = -dy / len;
                        let ny = dx / len;
                        
                        // ç¡®ä¿æ³•å‘é‡æŒ‡å‘å°çƒçš„ä¸€ä¾§
                        const toBallX = ball.x - collision.x;
                        const toBallY = ball.y - collision.y;
                        const dotToNormal = toBallX * nx + toBallY * ny;
                        
                        if (dotToNormal < 0) {
                            nx = -nx;
                            ny = -ny;
                        }
                        
                        // è®¡ç®—é€Ÿåº¦åœ¨æ³•å‘å’Œåˆ‡å‘ä¸Šçš„åˆ†é‡
                        const vn = ball.vx * nx + ball.vy * ny;
                        const vt = ball.vx * tx + ball.vy * ty;
                        
                        // å¦‚æœå°çƒæ­£åœ¨å‘çº¿ç§»åŠ¨ï¼ˆvn < 0ï¼‰ï¼Œåˆ™è¿›è¡Œåå¼¹
                        if (vn < 0) {
                            // åˆ†è§£é€Ÿåº¦ï¼šä¿ç•™åˆ‡å‘é€Ÿåº¦ï¼Œåå¼¹æ³•å‘é€Ÿåº¦
                            ball.vx = vt * tx - vn * nx * bounce;
                            ball.vy = vt * ty - vn * ny * bounce;
                            
                            // ä½ç½®ä¿®æ­£ï¼šå°†å°çƒæ¨å‡ºçº¿å¤–
                            ball.x = collision.x + nx * (ball.radius + 0.5);
                            ball.y = collision.y + ny * (ball.radius + 0.5);
                        }
                    }
                }
            });
            
            // åº”ç”¨æ‘©æ“¦ï¼ˆæ”¾åœ¨ç¢°æ’åï¼‰
            ball.vx *= friction;
            ball.vy *= friction;
            
            // ç”»å¸ƒè¾¹ç•Œç¢°æ’
            if (ball.y + ball.radius > canvas.height) {
                ball.y = canvas.height - ball.radius;
                ball.vy *= -bounce;
                ball.vx *= 0.95;
            }
            
            if (ball.x + ball.radius > canvas.width) {
                ball.x = canvas.width - ball.radius;
                ball.vx *= -bounce;
            }
            
            if (ball.x - ball.radius < 0) {
                ball.x = ball.radius;
                ball.vx *= -bounce;
            }
            
            if (ball.y - ball.radius < 0) {
                ball.y = ball.radius;
                ball.vy *= -bounce;
            }
            
            // éšœç¢ç‰©ç¢°æ’æ£€æµ‹
            obstacles.forEach(obs => {
                if (checkRectCircleCollision(obs, ball)) {
                    gameOver();
                }
            });
            
            // å°–åˆºç¢°æ’æ£€æµ‹
            spikes.forEach(spike => {
                const dist = Math.sqrt((ball.x - spike.x) ** 2 + (ball.y - spike.y) ** 2);
                if (dist < ball.radius + spike.size) {
                    gameOver();
                }
            });
            
            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
            const distToEnd = Math.sqrt((ball.x - endPoint.x) ** 2 + (ball.y - endPoint.y) ** 2);
            if (distToEnd < ball.radius + 20) {
                levelComplete();
            }
        }
        
        // ç¢°æ’æ£€æµ‹å‡½æ•°ï¼ˆæ”¹è¿›ç‰ˆï¼‰
        function checkLineCircleCollision(p1, p2, circle) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const lenSq = dx * dx + dy * dy;
            
            if (lenSq === 0) {
                // çº¿æ®µé€€åŒ–ä¸ºç‚¹
                const dist = Math.sqrt((circle.x - p1.x) ** 2 + (circle.y - p1.y) ** 2);
                if (dist < circle.radius) {
                    return { x: p1.x, y: p1.y };
                }
                return null;
            }
            
            // è®¡ç®—æŠ•å½±å‚æ•°
            let t = ((circle.x - p1.x) * dx + (circle.y - p1.y) * dy) / lenSq;
            
            // é™åˆ¶åœ¨çº¿æ®µèŒƒå›´å†…
            t = Math.max(0, Math.min(1, t));
            
            // è®¡ç®—çº¿æ®µä¸Šæœ€è¿‘çš„ç‚¹
            const closestX = p1.x + t * dx;
            const closestY = p1.y + t * dy;
            
            // è®¡ç®—è·ç¦»
            const distX = circle.x - closestX;
            const distY = circle.y - closestY;
            const dist = Math.sqrt(distX * distX + distY * distY);
            
            // æ£€æµ‹ç¢°æ’
            if (dist < circle.radius + 2) {  // å¢åŠ ä¸€ç‚¹å®¹å·®
                return { x: closestX, y: closestY };
            }
            
            return null;
        }
        
        function checkRectCircleCollision(rect, circle) {
            const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
            
            const dist = Math.sqrt((circle.x - closestX) ** 2 + (circle.y - closestY) ** 2);
            
            return dist < circle.radius;
        }
        
        // æ¸¸æˆçŠ¶æ€
        function gameOver() {
            isGameRunning = false;
            canvas.style.cursor = 'crosshair';
            
            // ä½¿ç”¨æ¨¡æ€æ¡†è€Œä¸æ˜¯alert
            setTimeout(() => {
                if (confirm('ğŸ’” å“å‘€ï¼æ’åˆ°éšœç¢ç‰©äº†ï¼\n\nç‚¹å‡»"ç¡®å®š"é‡æ–°å¼€å§‹ï¼Œ"å–æ¶ˆ"å›åˆ°ç”»çº¿')) {
                    resetBall();
                } else {
                    resetBall();
                }
            }, 100);
            
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100]);
            }
        }
        
        function levelComplete() {
            isGameRunning = false;
            canvas.style.cursor = 'crosshair';
            
            const messages = [
                `ğŸ’– ç¬¬${currentLevel}å¤©ï¼Œæ¯ä¸€å¤©éƒ½æ˜¯çˆ±çš„è§è¯ï¼`,
                `ğŸŒ¹ æ­å–œè¿‡å…³ï¼æˆ‘ä»¬çš„çˆ±æƒ…å·²ç»èµ°è¿‡${currentLevel}å¤©äº†ï¼`,
                `ğŸ’ å¤ªæ£’äº†ï¼ç¬¬${currentLevel}å¤©ï¼Œçˆ±ä½ ä¸å˜ï¼`,
                `âœ¨ å®Œç¾ï¼${currentLevel}å¤©çš„é™ªä¼´ï¼Œæ˜¯æœ€ç¾çš„æ—¶å…‰ï¼`,
                `ğŸ‰ æˆåŠŸï¼${currentLevel}å¤©çš„ç›¸å®ˆï¼Œæ¯ä¸€å¤©éƒ½æ˜¯å¹¸ç¦ï¼`
            ];
            
            document.getElementById('winMessage').textContent = messages[Math.floor(Math.random() * messages.length)];
            document.getElementById('winModal').style.display = 'flex';
            
            // é€šå…³éœ‡åŠ¨åé¦ˆ
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100, 50, 200]);
            }
        }
        
        // æ¸¸æˆå¾ªç¯
        function gameLoop() {
            updateBall();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // é¼ æ ‡/è§¦æ‘¸äº‹ä»¶
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: (clientX - rect.left) * (canvas.width / rect.width),
                y: (clientY - rect.top) * (canvas.height / rect.height)
            };
        }
        
        // ç»Ÿä¸€çš„ç»˜åˆ¶å¼€å§‹å¤„ç†
        function handleDrawStart(e) {
            if (e.cancelable) e.preventDefault();
            if (isGameRunning) return;
            isDrawing = true;
            const pos = getMousePos(e);
            currentLine = [pos];
            
            // æ·»åŠ è§¦æ‘¸åé¦ˆ
            canvas.style.cursor = 'grabbing';
        }
        
        // ç»Ÿä¸€çš„ç»˜åˆ¶ç§»åŠ¨å¤„ç†
        function handleDrawMove(e) {
            if (e.cancelable) e.preventDefault();
            if (!isDrawing || isGameRunning) return;
            const pos = getMousePos(e);
            
            // ä¼˜åŒ–çº¿æ¡é‡‡æ ·ï¼Œé¿å…ç‚¹å¤ªå¯†é›†
            const lastPoint = currentLine[currentLine.length - 1];
            const dist = Math.sqrt((pos.x - lastPoint.x) ** 2 + (pos.y - lastPoint.y) ** 2);
            if (dist > 3) {  // åªæœ‰è·ç¦»å¤§äº3åƒç´ æ‰æ·»åŠ ç‚¹
                currentLine.push(pos);
                draw();
            }
        }
        
        // ç»Ÿä¸€çš„ç»˜åˆ¶ç»“æŸå¤„ç†
        function handleDrawEnd(e) {
            if (e.cancelable) e.preventDefault();
            if (!isDrawing) return;
            isDrawing = false;
            if (currentLine.length > 1) {
                drawnLines.push([...currentLine]);
            }
            currentLine = [];
            canvas.style.cursor = 'crosshair';
            draw();
        }
        
        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousedown', handleDrawStart);
        canvas.addEventListener('mousemove', handleDrawMove);
        canvas.addEventListener('mouseup', handleDrawEnd);
        canvas.addEventListener('mouseleave', handleDrawEnd);
        
        // è§¦æ‘¸äº‹ä»¶
        canvas.addEventListener('touchstart', handleDrawStart, { passive: false });
        canvas.addEventListener('touchmove', handleDrawMove, { passive: false });
        canvas.addEventListener('touchend', handleDrawEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleDrawEnd, { passive: false });
        
        // é˜²æ­¢é¡µé¢æ»šåŠ¨
        document.body.addEventListener('touchmove', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // æŒ‰é’®äº‹ä»¶
        document.getElementById('startBtn').addEventListener('click', () => {
            if (drawnLines.length === 0) {
                alert('è¯·å…ˆç”»ä¸€äº›çº¿æ¡æ¥å¼•å¯¼å°çƒå“¦~');
                return;
            }
            isGameRunning = true;
            canvas.style.cursor = 'default';
            
            // æ·»åŠ è§¦æ„Ÿåé¦ˆï¼ˆæ”¯æŒçš„è®¾å¤‡ï¼‰
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            isGameRunning = false;
            drawnLines = [];
            currentLine = [];
            initLevel(currentLevel);
            canvas.style.cursor = 'crosshair';
            draw();
            
            if (navigator.vibrate) {
                navigator.vibrate(30);
            }
        });
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            if (isGameRunning) return;
            drawnLines = [];
            currentLine = [];
            draw();
            
            if (navigator.vibrate) {
                navigator.vibrate(30);
            }
        });
        
        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            document.getElementById('winModal').style.display = 'none';
            currentLevel++;
            if (currentLevel > maxLevel) {
                alert('ğŸŠ æ­å–œï¼ä½ å·²ç»å®Œæˆäº†æ‰€æœ‰248å…³ï¼æˆ‘ä»¬çš„çˆ±æƒ…ä¼šä¸€ç›´å»¶ç»­ä¸‹å»ï¼ğŸ’•');
                currentLevel = 1;
            }
            document.getElementById('levelDisplay').textContent = currentLevel;
            drawnLines = [];
            currentLine = [];
            initLevel(currentLevel);
            canvas.style.cursor = 'crosshair';
            draw();
            
            if (navigator.vibrate) {
                navigator.vibrate([50, 100, 50]);
            }
        });
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initLevel(currentLevel);
        draw();
        gameLoop();
    </script>
</body>
</html>
