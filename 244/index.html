<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <title>旋转世界—爱心轨迹操控 ｜ 恋爱244天纪念</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: 'Segoe UI', 'PingFang SC', 'Microsoft Yahei', sans-serif;
      --pink: #ff6fb7;
      --dark: #0c1020;
      --deep: #0d172b;
      --accent: #ffd26f;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: clamp(0.85rem, 2.5vh, 1.5rem);
      padding: clamp(1rem, 3vh, 2rem) clamp(0.8rem, 4vw, 1.8rem) clamp(1.2rem, 5vh, 3rem);
      background: radial-gradient(circle at top, #18233f, #080a14 70%);
      color: #fefefe;
      text-align: center;
    }

    .hud {
      width: min(720px, 100%);
      background: rgba(14, 20, 40, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 18px;
      padding: 1.2rem 1.6rem;
      box-shadow: 0 20px 40px rgba(5, 6, 12, 0.7);
      backdrop-filter: blur(12px);
    }

    .title {
      font-size: clamp(1.4rem, 4vw, 2rem);
      letter-spacing: 0.12em;
      font-weight: 700;
      color: var(--pink);
      margin-bottom: 0.4rem;
    }

    .stats {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1.2rem;
      font-size: 0.95rem;
      opacity: 0.95;
    }

    .stats span strong {
      color: var(--accent);
      font-size: 1.1rem;
    }

    .hint {
      margin-top: 0.8rem;
      font-size: 0.92rem;
      color: rgba(255, 255, 255, 0.85);
    }

    canvas {
      width: min(520px, 95vw);
      height: auto;
      max-width: 90vmin;
      border-radius: 24px;
      background: radial-gradient(circle, #0f1a2f, #05070f);
      box-shadow: 0 40px 80px rgba(5, 4, 11, 0.9);
      touch-action: none;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    .controls {
      display: none;
      width: min(520px, 100%);
      max-width: 92vmin;
      gap: 1rem;
      margin-top: 0.4rem;
    }

    .control-btn {
      flex: 1;
      border: none;
      border-radius: 22px;
      padding: 0.9rem 0;
      font-size: 1rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: white;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.12), 0 12px 24px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(10px);
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
      touch-action: manipulation;
    }

    .control-btn:active,
    .control-btn.active {
      transform: translateY(2px) scale(0.99);
      box-shadow: inset 0 0 18px rgba(255, 111, 183, 0.35), 0 8px 12px rgba(0, 0, 0, 0.25);
      border-color: rgba(255, 111, 183, 0.7);
    }

    .restart {
      border: none;
      background: linear-gradient(120deg, #ff89c0, #ff4f8c);
      color: white;
      padding: 0.85rem 2.8rem;
      border-radius: 999px;
      font-size: 1rem;
      letter-spacing: 0.1em;
      cursor: pointer;
      box-shadow: 0 15px 35px rgba(255, 79, 140, 0.35);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .restart:hover {
      transform: translateY(-3px);
      box-shadow: 0 18px 45px rgba(255, 79, 140, 0.45);
    }

    .restart.hidden {
      display: none;
    }

    .footer {
      font-size: clamp(0.82rem, 1.8vw, 0.95rem);
      color: rgba(255, 255, 255, 0.75);
      letter-spacing: 0.08em;
    }

    @media (max-width: 540px) {
      body {
        padding: 0.9rem 0.6rem 1.4rem;
        gap: 0.9rem;
      }

      .stats {
        flex-direction: column;
        gap: 0.3rem;
      }

      .hud {
        padding: 0.9rem 1rem;
      }

      canvas {
        width: min(460px, 88vw);
      }

      .controls {
        gap: 0.6rem;
      }
    }

    @media (max-width: 720px) {
      canvas {
        width: min(520px, 92vw);
        max-width: none;
      }

      .controls {
        display: flex;
      }
    }

    @media (max-height: 720px) {
      body {
        padding-top: 0.8rem;
        padding-bottom: 1.2rem;
        gap: 0.8rem;
      }

      canvas {
        width: min(460px, 80vmin);
      }

      .restart {
        padding: 0.75rem 2.1rem;
        font-size: 0.9rem;
      }
    }

    @media (max-height: 620px) {
      .hud {
        padding: 0.8rem 0.9rem;
      }

      .hint {
        font-size: 0.85rem;
        line-height: 1.4;
      }

      .controls {
        gap: 0.5rem;
      }
    }
  </style>
</head>

<body>
  <div class="hud">
    <div class="title">旋转世界—爱心轨迹操控 · 恋爱244天</div>
    <div class="stats">
      <span>得分：<strong id="score">0</strong></span>
      <span>生命：<strong id="lives">3</strong></span>
      <span>速度倍率：<strong id="speed">1.0×</strong></span>
    </div>
    <p class="hint">拖动 / 轻触圆盘、点击下方按钮或按 ← → ，让相爱的我们对准爱心并避开黑洞。轨道会持续加速，保持默契哦！</p>
  </div>

  <canvas id="game" width="520" height="520" aria-label="旋转世界爱心轨迹小游戏"></canvas>
  <div class="controls" aria-hidden="false">
    <button class="control-btn" data-direction="left">向左</button>
    <button class="control-btn" data-direction="right">向右</button>
  </div>
  <button id="restart" class="restart hidden">再次出发</button>
  <div class="footer">以 244 天的心动频率，继续旋转我们的宇宙 ❤️</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const speedEl = document.getElementById('speed');
    const restartBtn = document.getElementById('restart');
    const controlButtons = document.querySelectorAll('.control-btn');

    const baseSpeed = 0.0075;
    const maxSpeed = 0.045;
    const accel = 0.0000009;
    const heartTolerance = 0.16;
    const holeTolerance = 0.2;
    const controlState = { left: false, right: false };
    const controlStep = 0.09;

    let center = { x: canvas.width / 2, y: canvas.height / 2 };
    let diskRadius = canvas.width * 0.36;

    let rotation = 0;
    let rotationSpeed = baseSpeed;
    let playerAngle = -Math.PI / 2;
    let lives = 3;
    let score = 0;
    let isGameOver = false;
    let flashTimer = 0;
    let lastTimestamp = 0;

    const hearts = [];
    const holes = [];

    function resizeCanvas() {
      const viewportHeight = window.visualViewport?.height || window.innerHeight;
      const responsiveBase = Math.min(window.innerWidth, viewportHeight);
      const target = responsiveBase < 720 ? responsiveBase * 0.82 : 520;
      const size = Math.max(260, Math.min(520, target));
      canvas.width = canvas.height = size;
      center = { x: size / 2, y: size / 2 };
      diskRadius = size * 0.35;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function randAngle() {
      return Math.random() * Math.PI * 2;
    }

    function isAngleSafe(angle) {
      if (!holes.length) return true;
      return holes.every((hole) => {
        const diff = Math.abs(shortestAngleDiff(angle, hole.baseAngle));
        const blockRange = hole.width / 2 + holeTolerance + 0.08;
        return diff > blockRange;
      });
    }

    function safeAngle(maxAttempts = 80) {
      let angle = randAngle();
      for (let i = 0; i < maxAttempts; i++) {
        if (isAngleSafe(angle)) return angle;
        angle = randAngle();
      }
      return angle;
    }

    function createHeart() {
      return { baseAngle: safeAngle(), pulse: Math.random() * Math.PI * 2, blocked: 0 };
    }

    function createHole() {
      return { baseAngle: randAngle(), width: 0.25 + Math.random() * 0.1, cooldown: 0 };
    }

    function resetGame() {
      rotation = 0;
      rotationSpeed = baseSpeed;
      playerAngle = -Math.PI / 2;
      lives = 3;
      score = 0;
      isGameOver = false;
      flashTimer = 0;
      holes.length = 0;
      for (let i = 0; i < 3; i++) holes.push(createHole());
      hearts.length = 0;
      for (let i = 0; i < 6; i++) hearts.push(createHeart());
      updateHUD();
      restartBtn.classList.add('hidden');
    }

    function updateHUD() {
      scoreEl.textContent = score;
      livesEl.textContent = lives;
      speedEl.textContent = `${(rotationSpeed / baseSpeed).toFixed(1)}×`;
    }

    function shortestAngleDiff(a, b) {
      let diff = a - b;
      while (diff > Math.PI) diff -= Math.PI * 2;
      while (diff < -Math.PI) diff += Math.PI * 2;
      return diff;
    }

    function handleHearts(delta) {
      hearts.forEach((heart) => {
        heart.pulse += 0.08 * delta;
        const angle = heart.baseAngle + rotation;
        const diff = Math.abs(shortestAngleDiff(playerAngle, angle));
        if (diff < heartTolerance) {
          score += 1;
          heart.baseAngle = safeAngle();
          heart.blocked = 0;
          rotationSpeed = Math.min(maxSpeed, rotationSpeed + 0.0008);
          updateHUD();
          return;
        }

        const nearHole = holes.some((hole) => {
          const holeDiff = Math.abs(shortestAngleDiff(heart.baseAngle, hole.baseAngle));
          return holeDiff < (hole.width / 2 + holeTolerance + 0.05);
        });

        if (nearHole) {
          heart.blocked += delta;
          if (heart.blocked > 240) {
            heart.baseAngle = safeAngle();
            heart.blocked = 0;
          }
        } else {
          heart.blocked = Math.max(0, heart.blocked - delta * 0.3);
        }
      });
    }

    function handleHoles(delta) {
      holes.forEach((hole) => {
        if (hole.cooldown > 0) {
          hole.cooldown -= delta;
          return;
        }
        const angle = hole.baseAngle + rotation;
        const diff = Math.abs(shortestAngleDiff(playerAngle, angle));
        if (diff < holeTolerance) {
          lives -= 1;
          hole.cooldown = 90;
          flashTimer = 14;
          updateHUD();
          if (lives <= 0) {
            endGame();
          }
        }
      });
    }

    function endGame() {
      isGameOver = true;
      restartBtn.classList.remove('hidden');
    }

    function polarToCartesian(angle, distance) {
      return {
        x: center.x + Math.cos(angle) * distance,
        y: center.y + Math.sin(angle) * distance
      };
    }

    function drawTrack() {
      const outer = diskRadius + 48;
      const inner = diskRadius - 48;
      const gradient = ctx.createRadialGradient(center.x, center.y, inner, center.x, center.y, outer);
      gradient.addColorStop(0, '#152648');
      gradient.addColorStop(1, '#050814');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(center.x, center.y, outer, 0, Math.PI * 2);
      ctx.arc(center.x, center.y, inner, 0, Math.PI * 2, true);
      ctx.fill();

      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 12]);
      ctx.beginPath();
      ctx.arc(center.x, center.y, diskRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawHearts() {
      hearts.forEach((heart) => {
        const angle = heart.baseAngle + rotation;
        const pos = polarToCartesian(angle, diskRadius);
        const beat = 1 + Math.sin(heart.pulse) * 0.08;
        const size = 12 * beat;
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(angle + Math.PI / 2);
        ctx.scale(size / 12, size / 12);
        ctx.fillStyle = '#ff81c4';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(-6, -6, -12, 2, 0, 12);
        ctx.bezierCurveTo(12, 2, 6, -6, 0, 0);
        ctx.fill();
        ctx.restore();
      });
    }

    function drawHoles(delta) {
      holes.forEach((hole) => {
        const angle = hole.baseAngle + rotation;
        ctx.save();
        ctx.translate(center.x, center.y);
        ctx.rotate(angle);
        const width = hole.width;
        ctx.strokeStyle = 'rgba(23, 233, 255, 0.15)';
        ctx.lineWidth = 30;
        ctx.beginPath();
        ctx.arc(0, 0, diskRadius, -width / 2, width / 2);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(0,0,0,0.55)';
        ctx.lineWidth = 20;
        ctx.beginPath();
        ctx.arc(0, 0, diskRadius, -width / 2.5, width / 2.5);
        ctx.stroke();
        ctx.restore();
      });
    }

    function drawPlayer() {
      const pos = polarToCartesian(playerAngle, diskRadius);
      ctx.save();
      ctx.translate(pos.x, pos.y);
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 18);
      gradient.addColorStop(0, '#fff6f9');
      gradient.addColorStop(1, '#ff4f99');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, 14, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#2b0d24';
      ctx.beginPath();
      ctx.arc(0, 0, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawOverlay() {
      if (flashTimer > 0) {
        ctx.fillStyle = `rgba(255,120,150,${flashTimer / 20})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        flashTimer -= 1;
      }

      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.font = '500 16px "Segoe UI", "PingFang SC"';
      ctx.textAlign = 'center';
      ctx.fillText(`我们已经一起旋转了 244 天 · 得分 ${score}`, center.x, canvas.height - 24);

      if (isGameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffffff';
        ctx.font = '700 42px "Segoe UI", "PingFang SC"';
        ctx.fillText('默契暂停', center.x, center.y - 10);
        ctx.font = '400 20px "Segoe UI", "PingFang SC"';
        ctx.fillText(`得分 ${score} · 再试一次找回节奏`, center.x, center.y + 26);
      }
    }

    function drawScene(delta) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawTrack();
      drawHoles(delta);
      drawHearts();
      drawPlayer();
      drawOverlay();
    }

    function update(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const delta = Math.min(60, (timestamp - lastTimestamp) / (1000 / 60));
      lastTimestamp = timestamp;

      if (!isGameOver) {
        rotation += rotationSpeed * delta;
        rotationSpeed = Math.min(maxSpeed, rotationSpeed + accel * delta + score * 0.0000003);
        if (controlState.left) playerAngle -= controlStep * (delta / 60);
        if (controlState.right) playerAngle += controlStep * (delta / 60);
        handleHearts(delta);
        handleHoles(delta);
      }

      drawScene(delta);
      requestAnimationFrame(update);
    }

    // Controls
    let dragging = false;

    function setAngleFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
      const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
      playerAngle = Math.atan2(y - center.y, x - center.x);
    }

    canvas.addEventListener('pointerdown', (e) => {
      dragging = true;
      setAngleFromEvent(e);
    });

    window.addEventListener('pointermove', (e) => {
      if (dragging && !isGameOver) setAngleFromEvent(e);
    });

    window.addEventListener('pointerup', () => dragging = false);

    window.addEventListener('keydown', (e) => {
      if (isGameOver) return;
      if (e.key === 'ArrowLeft') playerAngle -= 0.12;
      if (e.key === 'ArrowRight') playerAngle += 0.12;
    });

    restartBtn.addEventListener('click', resetGame);

    controlButtons.forEach((btn) => {
      const direction = btn.dataset.direction;
      const activate = (e) => {
        e.preventDefault();
        controlState[direction] = true;
        btn.classList.add('active');
      };
      const deactivate = () => {
        controlState[direction] = false;
        btn.classList.remove('active');
      };
      btn.addEventListener('pointerdown', activate);
      btn.addEventListener('pointerup', deactivate);
      btn.addEventListener('pointerleave', deactivate);
      btn.addEventListener('pointercancel', deactivate);
      btn.addEventListener('touchstart', activate, { passive: false });
      btn.addEventListener('touchend', deactivate);
    });

    window.addEventListener('touchend', () => {
      controlState.left = false;
      controlState.right = false;
      controlButtons.forEach(btn => btn.classList.remove('active'));
    }, { passive: true });

    resetGame();
    requestAnimationFrame(update);
  </script>
</body>

</html>

